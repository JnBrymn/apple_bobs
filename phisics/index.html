<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Physics Simulations</title>
	<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		body {
			background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
			min-height: 100vh;
			font-family: Arial, sans-serif;
			padding: 20px 0;
		}

		.container {
			text-align: center;
		}

		h1 {
			color: white;
			margin-bottom: 20px;
			font-size: 2.5em;
			text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
		}

		canvas {
			background: #0a1929;
			border-radius: 10px;
			box-shadow: 0 10px 40px rgba(0,0,0,0.5);
		}

		.info {
			color: white;
			margin-top: 20px;
			font-size: 1.2em;
		}

		.ideas-section {
			max-width: 1200px;
			margin: 40px auto;
			padding: 20px;
		}

		.ideas-title {
			color: white;
			text-align: center;
			font-size: 2em;
			margin-bottom: 30px;
			text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
		}

		.ideas-grid {
			display: grid;
			grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
			gap: 20px;
		}

		.idea-card {
			background: rgba(255, 255, 255, 0.1);
			backdrop-filter: blur(10px);
			border-radius: 15px;
			padding: 20px;
			border: 2px solid rgba(255, 255, 255, 0.2);
			transition: transform 0.3s, background 0.3s;
			cursor: pointer;
		}

		.idea-card:hover {
			transform: translateY(-5px);
			background: rgba(255, 255, 255, 0.2);
		}

		.idea-card.active {
			background: rgba(255, 255, 255, 0.3);
			border-color: rgba(255, 255, 255, 0.5);
		}

		.idea-card h3 {
			color: white;
			font-size: 1.3em;
			margin-bottom: 10px;
		}

		.idea-card p {
			color: rgba(255, 255, 255, 0.8);
			line-height: 1.5;
		}
	</style>
</head>
<body>
	<div class="container">
		<h1>⚡ Physics Simulations ⚡</h1>
		<canvas id="canvas"></canvas>
		<div class="info">
			<p>Balls: <span id="ballCount">0</span></p>
			<p id="description">Click a simulation below to try it!</p>
		</div>
	</div>

	<div class="ideas-section">
		<h2 class="ideas-title">Click a Simulation to Try It!</h2>
		<div class="ideas-grid" id="ideasGrid"></div>
	</div>

	<script>
		const canvas = document.getElementById('canvas');
		const ctx = canvas.getContext('2d');
		
		const size = Math.min(window.innerWidth - 40, window.innerHeight - 200, 800);
		canvas.width = size;
		canvas.height = size;

		const centerX = canvas.width / 2;
		const centerY = canvas.height / 2;
		const radius = size / 2 - 20;
		const ballRadius = 8;

		let balls = [];
		let currentMode = 'circle';
		let animationId = null;

		const simulations = {
			circle: {
				title: 'Balls in Circle',
				description: 'When a ball hits the edge, 3 more appear! When balls collide, they disappear!',
				init: () => {
					balls = [];
					for (let i = 0; i < 3; i++) {
						const angle = Math.random() * Math.PI * 2;
						const distance = radius * 0.4;
						const x = centerX + Math.cos(angle) * distance;
						const y = centerY + Math.sin(angle) * distance;
						balls.push(new Ball(x, y));
					}
				},
				update: () => {
					balls.forEach(ball => {
						ball.x += ball.vx;
						ball.y += ball.vy;
						const dx = ball.x - centerX;
						const dy = ball.y - centerY;
						const distance = Math.sqrt(dx * dx + dy * dy);
						if (distance + ball.radius >= radius) {
							const nx = dx / distance;
							const ny = dy / distance;
							const dot = ball.vx * nx + ball.vy * ny;
							ball.vx -= 2 * dot * nx;
							ball.vy -= 2 * dot * ny;
							ball.x = centerX + nx * (radius - ball.radius);
							ball.y = centerY + ny * (radius - ball.radius);
							for (let i = 0; i < 3; i++) {
								const angle = Math.random() * Math.PI * 2;
								const spawnDistance = radius * 0.3;
								balls.push(new Ball(
									centerX + Math.cos(angle) * spawnDistance,
									centerY + Math.sin(angle) * spawnDistance
								));
							}
						}
					});
					checkCollisions();
				},
				draw: () => {
					ctx.beginPath();
					ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
					ctx.strokeStyle = 'rgba(255,255,255,0.5)';
					ctx.lineWidth = 3;
					ctx.stroke();
				}
			},
			box: {
				title: 'Particles in a Box',
				description: 'Particles bounce in a square box. When one hits a corner, it splits into 2!',
				init: () => {
					balls = [];
					for (let i = 0; i < 5; i++) {
						balls.push(new Ball(
							centerX + (Math.random() - 0.5) * radius * 1.2,
							centerY + (Math.random() - 0.5) * radius * 1.2
						));
					}
				},
				update: () => {
					const boxSize = radius * 1.2;
					balls.forEach(ball => {
						ball.x += ball.vx;
						ball.y += ball.vy;
						if (ball.x - ball.radius < centerX - boxSize || ball.x + ball.radius > centerX + boxSize) {
							ball.vx *= -1;
							ball.x = Math.max(centerX - boxSize + ball.radius, Math.min(centerX + boxSize - ball.radius, ball.x));
							if (Math.abs(ball.x - (centerX - boxSize)) < 5 || Math.abs(ball.x - (centerX + boxSize)) < 5) {
								balls.push(new Ball(ball.x, ball.y, -ball.vx, ball.vy));
							}
						}
						if (ball.y - ball.radius < centerY - boxSize || ball.y + ball.radius > centerY + boxSize) {
							ball.vy *= -1;
							ball.y = Math.max(centerY - boxSize + ball.radius, Math.min(centerY + boxSize - ball.radius, ball.y));
							if (Math.abs(ball.y - (centerY - boxSize)) < 5 || Math.abs(ball.y - (centerY + boxSize)) < 5) {
								balls.push(new Ball(ball.x, ball.y, ball.vx, -ball.vy));
							}
						}
					});
					checkCollisions();
				},
				draw: () => {
					const boxSize = radius * 1.2;
					ctx.strokeStyle = 'rgba(255,255,255,0.5)';
					ctx.lineWidth = 3;
					ctx.strokeRect(centerX - boxSize, centerY - boxSize, boxSize * 2, boxSize * 2);
				}
			},
			gravity: {
				title: 'Gravity Well',
				description: 'Balls orbit around center. When too close, they disappear and create 2 new balls!',
				init: () => {
					balls = [];
					for (let i = 0; i < 4; i++) {
						const angle = Math.random() * Math.PI * 2;
						const distance = radius * 0.6;
						const x = centerX + Math.cos(angle) * distance;
						const y = centerY + Math.sin(angle) * distance;
						const speed = 2;
						balls.push(new Ball(x, y, -Math.sin(angle) * speed, Math.cos(angle) * speed));
					}
				},
				update: () => {
					balls.forEach(ball => {
						const dx = centerX - ball.x;
						const dy = centerY - ball.y;
						const dist = Math.sqrt(dx * dx + dy * dy);
						const force = 0.1;
						ball.vx += (dx / dist) * force;
						ball.vy += (dy / dist) * force;
						ball.x += ball.vx;
						ball.y += ball.vy;
						if (dist < radius * 0.2) {
							const idx = balls.indexOf(ball);
							if (idx > -1) balls.splice(idx, 1);
							for (let i = 0; i < 2; i++) {
								const angle = Math.random() * Math.PI * 2;
								const distance = radius * 0.7;
								balls.push(new Ball(
									centerX + Math.cos(angle) * distance,
									centerY + Math.sin(angle) * distance,
									-Math.sin(angle) * 2,
									Math.cos(angle) * 2
								));
							}
						}
					});
					checkCollisions();
				},
				draw: () => {
					ctx.beginPath();
					ctx.arc(centerX, centerY, radius * 0.2, 0, Math.PI * 2);
					ctx.fillStyle = 'rgba(255,100,100,0.3)';
					ctx.fill();
					ctx.strokeStyle = 'rgba(255,255,255,0.5)';
					ctx.lineWidth = 3;
					ctx.stroke();
				}
			},
			explode: {
				title: 'Exploding Balls',
				description: 'When two balls collide, they explode into 5 smaller balls!',
				init: () => {
					balls = [];
					for (let i = 0; i < 4; i++) {
						const angle = Math.random() * Math.PI * 2;
						const distance = radius * 0.4;
						balls.push(new Ball(
							centerX + Math.cos(angle) * distance,
							centerY + Math.sin(angle) * distance
						));
					}
				},
				update: () => {
					balls.forEach(ball => {
						ball.x += ball.vx;
						ball.y += ball.vy;
						const dx = ball.x - centerX;
						const dy = ball.y - centerY;
						const distance = Math.sqrt(dx * dx + dy * dy);
						if (distance + ball.radius >= radius) {
							const nx = dx / distance;
							const ny = dy / distance;
							const dot = ball.vx * nx + ball.vy * ny;
							ball.vx -= 2 * dot * nx;
							ball.vy -= 2 * dot * ny;
							ball.x = centerX + nx * (radius - ball.radius);
							ball.y = centerY + ny * (radius - ball.radius);
						}
					});
					const toRemove = new Set();
					for (let i = 0; i < balls.length; i++) {
						if (toRemove.has(i)) continue;
						for (let j = i + 1; j < balls.length; j++) {
							if (toRemove.has(j)) continue;
							const ball1 = balls[i];
							const ball2 = balls[j];
							const dx = ball2.x - ball1.x;
							const dy = ball2.y - ball1.y;
							const distance = Math.sqrt(dx * dx + dy * dy);
							if (distance < ball1.radius + ball2.radius) {
								toRemove.add(i);
								toRemove.add(j);
								for (let k = 0; k < 5; k++) {
									const angle = Math.random() * Math.PI * 2;
									const speed = 3;
									balls.push(new Ball(
										(ball1.x + ball2.x) / 2,
										(ball1.y + ball2.y) / 2,
										Math.cos(angle) * speed,
										Math.sin(angle) * speed
									));
								}
								break;
							}
						}
					}
					const sortedIndices = Array.from(toRemove).sort((a, b) => b - a);
					sortedIndices.forEach(idx => balls.splice(idx, 1));
				},
				draw: () => {
					ctx.beginPath();
					ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
					ctx.strokeStyle = 'rgba(255,255,255,0.5)';
					ctx.lineWidth = 3;
					ctx.stroke();
				}
			},
			spiral: {
				title: 'Spiral Motion',
				description: 'Balls spiral inward. When they reach center, they bounce out and create 3 new spirals!',
				init: () => {
					balls = [];
					for (let i = 0; i < 3; i++) {
						const angle = Math.random() * Math.PI * 2;
						const distance = radius * 0.8;
						balls.push(new Ball(
							centerX + Math.cos(angle) * distance,
							centerY + Math.sin(angle) * distance
						));
					}
				},
				update: () => {
					balls.forEach(ball => {
						const dx = centerX - ball.x;
						const dy = centerY - ball.y;
						const dist = Math.sqrt(dx * dx + dy * dy);
						const angle = Math.atan2(dy, dx);
						ball.vx = Math.cos(angle + Math.PI / 2) * 2 - (dx / dist) * 0.5;
						ball.vy = Math.sin(angle + Math.PI / 2) * 2 - (dy / dist) * 0.5;
						ball.x += ball.vx;
						ball.y += ball.vy;
						if (dist < radius * 0.15) {
							const idx = balls.indexOf(ball);
							if (idx > -1) balls.splice(idx, 1);
							for (let i = 0; i < 3; i++) {
								const a = Math.random() * Math.PI * 2;
								const d = radius * 0.8;
								balls.push(new Ball(
									centerX + Math.cos(a) * d,
									centerY + Math.sin(a) * d
								));
							}
						}
					});
					checkCollisions();
				},
				draw: () => {
					ctx.beginPath();
					ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
					ctx.strokeStyle = 'rgba(255,255,255,0.5)';
					ctx.lineWidth = 3;
					ctx.stroke();
				}
			},
			magnetic: {
				title: 'Magnetic Balls',
				description: 'Balls have + and - charges. When opposites touch, they disappear and create 4 new balls!',
				init: () => {
					balls = [];
					for (let i = 0; i < 6; i++) {
						const angle = Math.random() * Math.PI * 2;
						const distance = radius * 0.5;
						const ball = new Ball(
							centerX + Math.cos(angle) * distance,
							centerY + Math.sin(angle) * distance
						);
						ball.charge = Math.random() > 0.5 ? 1 : -1;
						ball.color = ball.charge > 0 ? `hsl(200, 70%, 60%)` : `hsl(0, 70%, 60%)`;
						balls.push(ball);
					}
				},
				update: () => {
					balls.forEach(ball => {
						balls.forEach(other => {
							if (ball === other) return;
							const dx = other.x - ball.x;
							const dy = other.y - ball.y;
							const dist = Math.sqrt(dx * dx + dy * dy);
							if (dist > 0) {
								const force = (ball.charge * other.charge) * 0.1 / (dist * dist);
								ball.vx += (dx / dist) * force;
								ball.vy += (dy / dist) * force;
							}
						});
						ball.x += ball.vx;
						ball.y += ball.vy;
						const dx = ball.x - centerX;
						const dy = ball.y - centerY;
						const distance = Math.sqrt(dx * dx + dy * dy);
						if (distance + ball.radius >= radius) {
							const nx = dx / distance;
							const ny = dy / distance;
							const dot = ball.vx * nx + ball.vy * ny;
							ball.vx -= 2 * dot * nx;
							ball.vy -= 2 * dot * ny;
							ball.x = centerX + nx * (radius - ball.radius);
							ball.y = centerY + ny * (radius - ball.radius);
						}
					});
					const toRemove = new Set();
					for (let i = 0; i < balls.length; i++) {
						if (toRemove.has(i)) continue;
						for (let j = i + 1; j < balls.length; j++) {
							if (toRemove.has(j)) continue;
							const ball1 = balls[i];
							const ball2 = balls[j];
							const dx = ball2.x - ball1.x;
							const dy = ball2.y - ball1.y;
							const distance = Math.sqrt(dx * dx + dy * dy);
							if (distance < ball1.radius + ball2.radius && ball1.charge * ball2.charge < 0) {
								toRemove.add(i);
								toRemove.add(j);
								for (let k = 0; k < 4; k++) {
									const angle = Math.random() * Math.PI * 2;
									const distance = radius * 0.4;
									const newBall = new Ball(
										centerX + Math.cos(angle) * distance,
										centerY + Math.sin(angle) * distance
									);
									newBall.charge = Math.random() > 0.5 ? 1 : -1;
									newBall.color = newBall.charge > 0 ? `hsl(200, 70%, 60%)` : `hsl(0, 70%, 60%)`;
									balls.push(newBall);
								}
								break;
							}
						}
					}
					const sortedIndices = Array.from(toRemove).sort((a, b) => b - a);
					sortedIndices.forEach(idx => balls.splice(idx, 1));
				},
				draw: () => {
					ctx.beginPath();
					ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
					ctx.strokeStyle = 'rgba(255,255,255,0.5)';
					ctx.lineWidth = 3;
					ctx.stroke();
				}
			}
		};

		class Ball {
			constructor(x, y, vx = 0, vy = 0) {
				this.x = x;
				this.y = y;
				this.vx = vx || (Math.random() - 0.5) * 4;
				this.vy = vy || (Math.random() - 0.5) * 4;
				this.radius = ballRadius;
				this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
				this.charge = 0;
			}

			draw() {
				ctx.beginPath();
				ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
				ctx.fillStyle = this.color;
				ctx.fill();
				ctx.strokeStyle = 'rgba(255,255,255,0.3)';
				ctx.lineWidth = 1;
				ctx.stroke();
			}
		}

		function checkCollisions() {
			const toRemove = new Set();
			for (let i = 0; i < balls.length; i++) {
				if (toRemove.has(i)) continue;
				for (let j = i + 1; j < balls.length; j++) {
					if (toRemove.has(j)) continue;
					const ball1 = balls[i];
					const ball2 = balls[j];
					const dx = ball2.x - ball1.x;
					const dy = ball2.y - ball1.y;
					const distance = Math.sqrt(dx * dx + dy * dy);
					if (distance < ball1.radius + ball2.radius) {
						toRemove.add(i);
						toRemove.add(j);
						break;
					}
				}
			}
			const sortedIndices = Array.from(toRemove).sort((a, b) => b - a);
			sortedIndices.forEach(index => balls.splice(index, 1));
		}

		function switchMode(mode) {
			currentMode = mode;
			const sim = simulations[mode];
			sim.init();
			document.getElementById('description').textContent = sim.description;
			document.querySelectorAll('.idea-card').forEach(card => {
				card.classList.remove('active');
			});
			event.target.closest('.idea-card')?.classList.add('active');
		}

		function update() {
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			const sim = simulations[currentMode];
			sim.draw();
			sim.update();
			balls.forEach(ball => ball.draw());
			document.getElementById('ballCount').textContent = balls.length;
			animationId = requestAnimationFrame(update);
		}

		// Create idea cards
		const grid = document.getElementById('ideasGrid');
		Object.keys(simulations).forEach((key, index) => {
			const sim = simulations[key];
			const card = document.createElement('div');
			card.className = 'idea-card';
			if (index === 0) card.classList.add('active');
			card.innerHTML = `<h3>${sim.title}</h3><p>${sim.description}</p>`;
			card.onclick = () => switchMode(key);
			grid.appendChild(card);
		});

		// Start with first simulation
		simulations.circle.init();
		update();
	</script>
</body>
</html>