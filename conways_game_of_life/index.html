<!--
Conway's Game of Life - 3D Version
Features:
- Run and stop simulations
- Change speed
- Change board size (now 3D!)
- Draw own starting position
- Choose from several automatic starting states from a dropdown list
- 3D visualization with rotation controls
-->

<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Conway's Game of Life - 3D</title>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
	<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		body {
			font-family: Comic Sans MS, sans-serif;
			background: #1a1a1a;
			color: #fff;
			padding: 20px;
			overflow-x: hidden;
		}

		.container {
			max-width: 1400px;
			margin: 0 auto;
		}

		h1 {
			text-align: center;
			margin-bottom: 20px;
			color: #4CAF50;
		}

		.controls {
			display: flex;
			flex-wrap: wrap;
			gap: 15px;
			margin-bottom: 20px;
			align-items: center;
			justify-content: center;
		}

		.control-group {
			display: flex;
			flex-direction: column;
			gap: 5px;
		}

		label {
			font-size: 12px;
			color: #aaa;
		}

		button {
			padding: 10px 20px;
			background: #4CAF50;
			color: white;
			border: none;
			border-radius: 5px;
			cursor: pointer;
			font-size: 14px;
			transition: background 0.3s;
		}

		button:hover {
			background: #45a049;
		}

		button:disabled {
			background: #666;
			cursor: not-allowed;
		}

		button.stop {
			background: #f44336;
		}

		button.stop:hover {
			background: #da190b;
		}

		select, input[type="range"] {
			padding: 8px;
			background: #333;
			color: white;
			border: 1px solid #555;
			border-radius: 5px;
		}

		.speed-display, .size-display {
			font-size: 12px;
			color: #4CAF50;
			min-width: 80px;
		}

		.canvas-container {
			display: flex;
			justify-content: center;
			margin-bottom: 20px;
			position: relative;
		}

		#gameCanvas {
			width: 800px;
			height: 600px;
			border: 2px solid #4CAF50;
			background: #000;
		}

		.info {
			text-align: center;
			color: #aaa;
			font-size: 14px;
			margin-top: 10px;
		}

		.generation {
			text-align: center;
			font-size: 18px;
			color: #4CAF50;
			margin-bottom: 10px;
		}

		.rules-box {
			background: #2a2a2a;
			border: 2px solid #4CAF50;
			border-radius: 10px;
			padding: 20px;
			margin-bottom: 20px;
			max-width: 800px;
			margin-left: auto;
			margin-right: auto;
		}

		.rules-title {
			color: #4CAF50;
			font-size: 20px;
			margin-bottom: 15px;
			text-align: center;
			cursor: pointer;
			user-select: none;
		}

		.rules-title:hover {
			color: #66ff66;
		}

		.rules-content {
			color: #ddd;
			font-size: 16px;
			line-height: 1.6;
		}

		.rules-content.hidden {
			display: none;
		}

		.rule-item {
			margin-bottom: 15px;
			padding-left: 25px;
			position: relative;
		}

		.rule-item::before {
			content: "‚Ä¢";
			color: #4CAF50;
			font-size: 24px;
			position: absolute;
			left: 0;
		}

		.camera-info {
			position: absolute;
			top: 10px;
			left: 10px;
			background: rgba(0, 0, 0, 0.7);
			padding: 10px;
			border-radius: 5px;
			font-size: 12px;
			color: #aaa;
		}
	</style>
</head>
<body>
	<div class="container">
		<h1>Conway's Game of Life - 3D! üéÆ</h1>
		
		<div class="rules-box">
			<div class="rules-title" id="rulesTitle">üìñ How It Works (Click to Show/Hide)</div>
			<div class="rules-content hidden" id="rulesContent">
				<p style="margin-bottom: 15px; text-align: center; color: #4CAF50; font-size: 18px;">
					<strong>It's like a tiny 3D world where cells live or die!</strong>
				</p>
				
				<div class="rule-item">
					<strong>Each green cube is a living cell.</strong> Each empty space is a dead cell.
				</div>
				
				<div class="rule-item">
					<strong>Every cell has 26 neighbors</strong> (all the cubes around it in 3D space - up, down, left, right, front, back, and all the corners!).
				</div>
				
				<div class="rule-item">
					<strong>If a living cell has 4, 5, 6, or 7 neighbors, it stays alive!</strong> Otherwise, it dies (too lonely or too crowded).
				</div>
				
				<div class="rule-item">
					<strong>If a dead cell has 3, 5, 6, 7, or 8 neighbors, it comes to life!</strong> Like magic! (This is called Bays' 3D Life rule: 4567/35678)
				</div>
				
				<div class="rule-item">
					<strong>Drag with your mouse to rotate the 3D world!</strong> Scroll to zoom in and out.
				</div>
				
				<p style="margin-top: 20px; text-align: center; color: #aaa; font-size: 14px;">
					Try clicking "Random" in the preset patterns to see a cool 3D pattern!
				</p>
			</div>
		</div>
		
		<div class="generation" id="generation">Generation: 0</div>
		
		<div class="controls">
			<button id="playPauseBtn">Start</button>
			<button id="clearBtn">Clear</button>
			<button id="resetBtn">Reset</button>
			
			<div class="control-group">
				<label>Speed</label>
				<div style="display: flex; align-items: center; gap: 10px;">
					<input type="range" id="speedSlider" min="1" max="20" value="5">
					<span class="speed-display" id="speedDisplay">5</span>
				</div>
			</div>
			
			<div class="control-group">
				<label>Board Size</label>
				<div style="display: flex; align-items: center; gap: 10px;">
					<input type="range" id="sizeSlider" min="10" max="30" value="20" step="5">
					<span class="size-display" id="sizeDisplay">20x20x20</span>
				</div>
			</div>
			
			<div class="control-group">
				<label>Preset Patterns</label>
				<select id="presetSelect">
					<option value="none">None (Draw Your Own)</option>
					<option value="random">Random</option>
					<option value="block">2x2x2 Block (Still Life)</option>
					<option value="line">Line</option>
					<option value="glider3d">Simple Glider</option>
					<option value="oscillator">Small Oscillator</option>
					<option value="sphere">Sphere</option>
				</select>
			</div>
		</div>
		
		<div class="canvas-container">
			<div class="camera-info">
				üñ±Ô∏è WASD to rotate | Scroll to zoom | Left-click to toggle cells
			</div>
			<div id="gameCanvas"></div>
		</div>
		
		<div class="info">
			Click on cubes to toggle them on/off. Use presets to load patterns. Drag to rotate the 3D view!
		</div>
	</div>

	<script>
		// Three.js setup
		let scene, camera, renderer;
		let boardSize = 20;
		let board = [];
		let nextBoard = [];
		let isRunning = false;
		let animationId = null;
		let generation = 0;
		let speed = 5;
		let lastUpdate = 0;
		let initialBoard = [];
		let cellMeshes = [];
		let raycaster, mouse;
		let isMouseDown = false;
		
		// Camera controls
		let cameraAngleX = Math.PI / 4;
		let cameraAngleY = Math.PI / 4;
		let cameraDistance = boardSize * 1.2;
		let isDragging = false;
		let lastMouseX = 0;
		let lastMouseY = 0;
		let keysPressed = {};

		// Bays' 3D Life rule: 4567/35678
		// Survival: 4, 5, 6, or 7 neighbors
		// Birth: 3, 5, 6, 7, or 8 neighbors
		const SURVIVE_VALUES = [4, 5, 6, 7];
		const BIRTH_VALUES = [3, 5, 6, 7, 8];
		
		function shouldSurvive(neighborCount) {
			return SURVIVE_VALUES.includes(neighborCount);
		}
		
		function shouldBirth(neighborCount) {
			return BIRTH_VALUES.includes(neighborCount);
		}

		function initThreeJS() {
			const container = document.getElementById('gameCanvas');
			
			scene = new THREE.Scene();
			scene.background = new THREE.Color(0x000000);

			camera = new THREE.PerspectiveCamera(75, 800 / 600, 0.1, 1000);
			camera.position.set(boardSize * 0.8, boardSize * 0.8, boardSize * 0.8);
			camera.lookAt(boardSize / 2, boardSize / 2, boardSize / 2);

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(800, 600);
			container.appendChild(renderer.domElement);
			
			// Manual camera controls
			updateCameraPosition();

			// Add lights
			const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
			scene.add(ambientLight);

			const directionalLight1 = new THREE.DirectionalLight(0x4CAF50, 0.8);
			directionalLight1.position.set(1, 1, 1);
			scene.add(directionalLight1);

			const directionalLight2 = new THREE.DirectionalLight(0x4CAF50, 0.4);
			directionalLight2.position.set(-1, -1, -1);
			scene.add(directionalLight2);

			// Raycaster for mouse picking
			raycaster = new THREE.Raycaster();
			mouse = new THREE.Vector2();

			// Mouse events
			renderer.domElement.addEventListener('mousedown', onMouseDown, false);
			renderer.domElement.addEventListener('mousemove', onMouseMove, false);
			renderer.domElement.addEventListener('mouseup', onMouseUp, false);
			renderer.domElement.addEventListener('wheel', onMouseWheel, false);
			renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
			
			// Keyboard events for WASD rotation
			window.addEventListener('keydown', onKeyDown, false);
			window.addEventListener('keyup', onKeyUp, false);
		}
		
		function updateCameraPosition() {
			const centerX = boardSize / 2;
			const centerY = boardSize / 2;
			const centerZ = boardSize / 2;
			
			camera.position.x = centerX + cameraDistance * Math.sin(cameraAngleY) * Math.cos(cameraAngleX);
			camera.position.y = centerY + cameraDistance * Math.sin(cameraAngleX);
			camera.position.z = centerZ + cameraDistance * Math.cos(cameraAngleY) * Math.cos(cameraAngleX);
			camera.lookAt(centerX, centerY, centerZ);
		}

		function initBoard() {
			board = [];
			nextBoard = [];
			for (let z = 0; z < boardSize; z++) {
				board[z] = [];
				nextBoard[z] = [];
				for (let y = 0; y < boardSize; y++) {
					board[z][y] = [];
					nextBoard[z][y] = [];
					for (let x = 0; x < boardSize; x++) {
						board[z][y][x] = 0;
						nextBoard[z][y][x] = 0;
					}
				}
			}
			initialBoard = JSON.parse(JSON.stringify(board));
			generation = 0;
			updateGeneration();
			updateVisualization();
		}

		function getColorFromNeighborCount(neighborCount) {
			// Map neighbor count (0-26) to a color gradient
			// From dark green (few neighbors) to bright yellow (many neighbors)
			const maxNeighbors = 26;
			const ratio = neighborCount / maxNeighbors;
			
			// Create a gradient from dark green to bright yellow
			let r, g, b;
			if (ratio < 0.5) {
				// Green to yellow-green
				const localRatio = ratio * 2;
				r = Math.floor(74 + localRatio * 181); // 74 -> 255
				g = Math.floor(175 + localRatio * 80);  // 175 -> 255
				b = Math.floor(50 - localRatio * 50);   // 50 -> 0
			} else {
				// Yellow-green to bright yellow
				const localRatio = (ratio - 0.5) * 2;
				r = 255;
				g = 255;
				b = Math.floor(205 - localRatio * 205); // 205 -> 0
			}
			
			return (r << 16) | (g << 8) | b;
		}

		function updateVisualization() {
			// Remove old meshes
			cellMeshes.forEach(mesh => {
				scene.remove(mesh);
				mesh.geometry.dispose();
				mesh.material.dispose();
			});
			cellMeshes = [];

			// Create cubes for living cells with colors based on neighbor count
			const geometry = new THREE.BoxGeometry(0.9, 0.9, 0.9);

			for (let z = 0; z < boardSize; z++) {
				for (let y = 0; y < boardSize; y++) {
					for (let x = 0; x < boardSize; x++) {
						if (board[z][y][x] === 1) {
							const neighborCount = countNeighbors(x, y, z);
							const color = getColorFromNeighborCount(neighborCount);
							
							const material = new THREE.MeshPhongMaterial({ 
								color: color,
								emissive: color,
								emissiveIntensity: 0.2
							});
							
							const cube = new THREE.Mesh(geometry, material);
							cube.position.set(x, y, z);
							cube.userData = { x, y, z };
							scene.add(cube);
							cellMeshes.push(cube);
						}
					}
				}
			}
		}

		function countNeighbors(x, y, z) {
			let count = 0;
			for (let dz = -1; dz <= 1; dz++) {
				for (let dy = -1; dy <= 1; dy++) {
					for (let dx = -1; dx <= 1; dx++) {
						if (dx === 0 && dy === 0 && dz === 0) continue;
						// Wrap around using modulo (toroidal)
						const nx = (x + dx + boardSize) % boardSize;
						const ny = (y + dy + boardSize) % boardSize;
						const nz = (z + dz + boardSize) % boardSize;
						count += board[nz][ny][nx];
					}
				}
			}
			return count;
		}

		function updateGeneration() {
			document.getElementById('generation').textContent = `Generation: ${generation}`;
		}

		function nextGeneration() {
			for (let z = 0; z < boardSize; z++) {
				for (let y = 0; y < boardSize; y++) {
					for (let x = 0; x < boardSize; x++) {
						const neighbors = countNeighbors(x, y, z);
						if (board[z][y][x] === 1) {
							// Survive if neighbor count matches survival rule
							nextBoard[z][y][x] = shouldSurvive(neighbors) ? 1 : 0;
						} else {
							// Birth if neighbor count matches birth rule
							nextBoard[z][y][x] = shouldBirth(neighbors) ? 1 : 0;
						}
					}
				}
			}
			
			const temp = board;
			board = nextBoard;
			nextBoard = temp;
			generation++;
			updateGeneration();
			updateVisualization();
		}

		function animate() {
			requestAnimationFrame(animate);
			
			// Handle WASD rotation
			const rotationSpeed = 0.02;
			if (keysPressed['w'] || keysPressed['W']) {
				cameraAngleX -= rotationSpeed;
				cameraAngleX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraAngleX));
				updateCameraPosition();
			}
			if (keysPressed['s'] || keysPressed['S']) {
				cameraAngleX += rotationSpeed;
				cameraAngleX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraAngleX));
				updateCameraPosition();
			}
			if (keysPressed['a'] || keysPressed['A']) {
				cameraAngleY -= rotationSpeed;
				updateCameraPosition();
			}
			if (keysPressed['d'] || keysPressed['D']) {
				cameraAngleY += rotationSpeed;
				updateCameraPosition();
			}
			
			if (isRunning) {
				const currentTime = performance.now();
				if (currentTime - lastUpdate >= 1000 / speed) {
					nextGeneration();
					lastUpdate = currentTime;
				}
			}
			
			renderer.render(scene, camera);
		}
		
		function onKeyDown(event) {
			keysPressed[event.key] = true;
		}
		
		function onKeyUp(event) {
			keysPressed[event.key] = false;
		}

		function startSimulation() {
			if (!isRunning) {
				isRunning = true;
				document.getElementById('playPauseBtn').textContent = 'Stop';
				document.getElementById('playPauseBtn').classList.add('stop');
				lastUpdate = performance.now();
			}
		}

		function stopSimulation() {
			if (isRunning) {
				isRunning = false;
				document.getElementById('playPauseBtn').textContent = 'Start';
				document.getElementById('playPauseBtn').classList.remove('stop');
			}
		}

		function onMouseDown(event) {
			if (event.button === 0) { // Left mouse button
				if (!isRunning) {
					isMouseDown = true;
					handleMouseClick(event);
				}
			} else if (event.button === 2 || event.button === 1) { // Right or middle mouse button
				isDragging = true;
				lastMouseX = event.clientX;
				lastMouseY = event.clientY;
			}
		}

		function onMouseMove(event) {
			if (isDragging) {
				const deltaX = event.clientX - lastMouseX;
				const deltaY = event.clientY - lastMouseY;
				
				cameraAngleY += deltaX * 0.01;
				cameraAngleX += deltaY * 0.01;
				
				// Limit vertical rotation
				cameraAngleX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraAngleX));
				
				updateCameraPosition();
				
				lastMouseX = event.clientX;
				lastMouseY = event.clientY;
			} else if (isMouseDown && !isRunning) {
				handleMouseClick(event);
			}
		}

		function onMouseUp(event) {
			if (event.button === 0) {
				isMouseDown = false;
			} else {
				isDragging = false;
			}
		}
		
		function onMouseWheel(event) {
			event.preventDefault();
			cameraDistance += event.deltaY * 0.01;
			cameraDistance = Math.max(boardSize * 0.5, Math.min(boardSize * 3, cameraDistance));
			updateCameraPosition();
		}

		function handleMouseClick(event) {
			const rect = renderer.domElement.getBoundingClientRect();
			mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
			mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

			raycaster.setFromCamera(mouse, camera);
			const intersects = raycaster.intersectObjects(cellMeshes);

			if (intersects.length > 0) {
				const clickedMesh = intersects[0].object;
				const { x, y, z } = clickedMesh.userData;
				toggleCell(x, y, z);
			} else {
				// Try to add a cell near where clicked
				const distance = boardSize * 0.5;
				const direction = new THREE.Vector3();
				raycaster.ray.direction.normalize();
				const point = raycaster.ray.origin.clone().add(
					raycaster.ray.direction.multiplyScalar(distance)
				);
				
				const x = Math.round(point.x);
				const y = Math.round(point.y);
				const z = Math.round(point.z);
				
				if (x >= 0 && x < boardSize && 
					y >= 0 && y < boardSize && 
					z >= 0 && z < boardSize) {
					toggleCell(x, y, z);
				}
			}
		}

		function toggleCell(x, y, z) {
			if (x >= 0 && x < boardSize && 
				y >= 0 && y < boardSize && 
				z >= 0 && z < boardSize) {
				board[z][y][x] = board[z][y][x] === 1 ? 0 : 1;
				initialBoard = JSON.parse(JSON.stringify(board));
				updateVisualization();
			}
		}

		function loadPreset(preset) {
			stopSimulation();
			initBoard();
			
			const centerX = Math.floor(boardSize / 2);
			const centerY = Math.floor(boardSize / 2);
			const centerZ = Math.floor(boardSize / 2);
			
			switch(preset) {
				case 'random':
					for (let z = 0; z < boardSize; z++) {
						for (let y = 0; y < boardSize; y++) {
							for (let x = 0; x < boardSize; x++) {
								board[z][y][x] = Math.random() > 0.85 ? 1 : 0;
							}
						}
					}
					break;
					
				case 'block':
					// 2x2x2 block - a still life pattern
					for (let dz = 0; dz < 2; dz++) {
						for (let dy = 0; dy < 2; dy++) {
							for (let dx = 0; dx < 2; dx++) {
								const x = centerX + dx;
								const y = centerY + dy;
								const z = centerZ + dz;
								if (x >= 0 && x < boardSize && 
									y >= 0 && y < boardSize && 
									z >= 0 && z < boardSize) {
									board[z][y][x] = 1;
								}
							}
						}
					}
					break;
					
				case 'line':
					// Simple line pattern
					for (let i = -3; i <= 3; i++) {
						const x = centerX + i;
						const y = centerY;
						const z = centerZ;
						if (x >= 0 && x < boardSize && 
							y >= 0 && y < boardSize && 
							z >= 0 && z < boardSize) {
							board[z][y][x] = 1;
						}
					}
					break;
					
				case 'glider3d':
					// Simple 3D glider pattern (known to work with 4567/35678)
					// A small pattern that moves through space
					board[centerZ][centerY][centerX] = 1;
					board[centerZ][centerY][centerX + 1] = 1;
					board[centerZ][centerY + 1][centerX] = 1;
					board[centerZ][centerY + 1][centerX + 1] = 1;
					board[centerZ + 1][centerY][centerX] = 1;
					board[centerZ + 1][centerY + 1][centerX + 1] = 1;
					break;
					
				case 'oscillator':
					// Small oscillator pattern
					// Creates a pattern that oscillates between states
					board[centerZ][centerY][centerX] = 1;
					board[centerZ][centerY][centerX + 1] = 1;
					board[centerZ][centerY + 1][centerX] = 1;
					board[centerZ][centerY + 1][centerX + 1] = 1;
					board[centerZ + 1][centerY][centerX] = 1;
					board[centerZ + 1][centerY][centerX + 1] = 1;
					board[centerZ + 1][centerY + 1][centerX] = 1;
					board[centerZ + 1][centerY + 1][centerX + 1] = 1;
					// Add a few more cells to create oscillation
					board[centerZ][centerY + 2][centerX] = 1;
					board[centerZ][centerY + 2][centerX + 1] = 1;
					break;
					
				case 'sphere':
					const radius = Math.floor(boardSize / 4);
					for (let z = 0; z < boardSize; z++) {
						for (let y = 0; y < boardSize; y++) {
							for (let x = 0; x < boardSize; x++) {
								const dx = x - centerX;
								const dy = y - centerY;
								const dz = z - centerZ;
								const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
								if (dist <= radius) {
									board[z][y][x] = 1;
								}
							}
						}
					}
					break;
			}
			
			initialBoard = JSON.parse(JSON.stringify(board));
			updateVisualization();
		}

		// Event listeners
		document.getElementById('playPauseBtn').addEventListener('click', () => {
			if (isRunning) {
				stopSimulation();
			} else {
				startSimulation();
			}
		});

		document.getElementById('clearBtn').addEventListener('click', () => {
			stopSimulation();
			initBoard();
		});

		document.getElementById('resetBtn').addEventListener('click', () => {
			stopSimulation();
			board = JSON.parse(JSON.stringify(initialBoard));
			generation = 0;
			updateGeneration();
			updateVisualization();
		});

		document.getElementById('speedSlider').addEventListener('input', (e) => {
			speed = parseInt(e.target.value);
			document.getElementById('speedDisplay').textContent = speed;
		});

			document.getElementById('sizeSlider').addEventListener('input', (e) => {
			stopSimulation();
			boardSize = parseInt(e.target.value);
			document.getElementById('sizeDisplay').textContent = `${boardSize}x${boardSize}x${boardSize}`;
			cameraDistance = boardSize * 1.2;
			updateCameraPosition();
			initBoard();
		});

		document.getElementById('presetSelect').addEventListener('change', (e) => {
			if (e.target.value !== 'none') {
				loadPreset(e.target.value);
			}
		});

		document.getElementById('rulesTitle').addEventListener('click', () => {
			const rulesContent = document.getElementById('rulesContent');
			rulesContent.classList.toggle('hidden');
			const rulesTitle = document.getElementById('rulesTitle');
			if (rulesContent.classList.contains('hidden')) {
				rulesTitle.textContent = 'üìñ How It Works (Click to Show/Hide)';
			} else {
				rulesTitle.textContent = 'üìñ How It Works (Click to Hide)';
			}
		});

		// Initialize
		initThreeJS();
		initBoard();
		animate();
	</script>
</body>
</html>
