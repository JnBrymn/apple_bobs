<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Obby - Obstacle Course Adventure</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }
        
        .ui {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            z-index: 100;
        }
        
        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            z-index: 200;
        }
        
        .game-over h2 {
            color: #FF6B6B;
            margin-bottom: 20px;
        }
        
        .restart-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 25px;
            cursor: pointer;
            margin-top: 20px;
        }
        
        .restart-btn:hover {
            background: #45a049;
        }
        
        .instructions {
            position: fixed;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 16px;
            text-align: right;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            z-index: 100;
        }
        
        .crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 150;
            pointer-events: none;
        }
        
        #gameContainer {
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <div class="ui">
        <div>Checkpoint: <span id="checkpoint">0</span></div>
        <div>Deaths: <span id="deaths">0</span></div>
        <div>Time: <span id="time">0</span>s</div>
    </div>
    
    <div class="instructions">
        <div>üéÆ WASD to move</div>
        <div>üñ±Ô∏è Click to look around</div>
        <div>‚¨ÜÔ∏è SPACE to jump</div>
        <div>üéØ Reach the end!</div>
    </div>
    
    <div class="crosshair">+</div>
    
    <div id="gameContainer"></div>
    
    <div class="game-over" id="gameOver">
        <h2>Obby Complete!</h2>
        <p>Checkpoints Reached: <span id="finalCheckpoint">0</span></p>
        <p>Total Deaths: <span id="finalDeaths">0</span></p>
        <p>Time: <span id="finalTime">0</span>s</p>
        <button class="restart-btn" onclick="restartGame()">Play Again!</button>
    </div>

    <script>
        // Wait for Three.js to load
        window.addEventListener('load', function() {
            // Check if Three.js loaded
            if (typeof THREE === 'undefined') {
                alert('Three.js failed to load! Please refresh the page.');
                return;
            }
            
            console.log('Three.js loaded successfully!');
            
            // Create scene
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            // Create camera
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            
            // Create renderer
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameContainer').appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Game variables
            let checkpoint = 0;
            let deaths = 0;
            let startTime = Date.now();
            let gameRunning = true;
            let playerPosition = new THREE.Vector3(0, 2, 0);
            let playerVelocity = new THREE.Vector3(0, 0, 0);
            let playerRotation = new THREE.Euler(0, 0, 0);
            let onGround = false;
            
            // Physics constants
            const gravity = -0.02;
            const jumpPower = 0.3;
            const moveSpeed = 0.1;
            const mouseSensitivity = 0.002;
            
            // Create platforms with lots of different activities!
            const platforms = [
                { pos: [0, 0, 0], size: [10, 1, 10], color: 0x4CAF50, type: 'start' },      // Start
                { pos: [0, 0, 8], size: [8, 1, 8], color: 0xFFD700, type: 'checkpoint' },    // Checkpoint 1
                { pos: [0, 0, 16], size: [6, 1, 6], color: 0x2196F3, type: 'normal' },       // Platform 2
                { pos: [0, 0, 24], size: [8, 1, 8], color: 0xFFD700, type: 'checkpoint' },   // Checkpoint 2
                { pos: [0, 0, 32], size: [6, 1, 6], color: 0x9C27B0, type: 'moving' },       // Moving platform!
                { pos: [0, 0, 40], size: [8, 1, 8], color: 0xFFD700, type: 'checkpoint' },   // Checkpoint 3
                { pos: [0, 0, 48], size: [6, 1, 6], color: 0x00BCD4, type: 'spinning' },     // Spinning platform!
                { pos: [0, 0, 56], size: [8, 1, 8], color: 0xFFD700, type: 'checkpoint' },   // Checkpoint 4
                { pos: [0, 0, 64], size: [10, 1, 10], color: 0xF44336, type: 'final' }       // Final platform
            ];
            
            // Create lots of different obstacles and activities!
            const obstacles = [
                // Spinning bars to dodge
                { pos: [0, 2, 12], size: [0.2, 4, 0.2], color: 0xFF0000, type: 'spinning', spinSpeed: 0.1 },
                { pos: [0, 2, 20], size: [0.2, 4, 0.2], color: 0xFF0000, type: 'spinning', spinSpeed: 0.08 },
                { pos: [0, 2, 28], size: [0.2, 4, 0.2], color: 0xFF0000, type: 'spinning', spinSpeed: 0.12 },
                { pos: [0, 2, 36], size: [0.2, 4, 0.2], color: 0xFF0000, type: 'spinning', spinSpeed: 0.15 },
                { pos: [0, 2, 44], size: [0.2, 4, 0.2], color: 0xFF0000, type: 'spinning', spinSpeed: 0.09 },
                { pos: [0, 2, 52], size: [0.2, 4, 0.2], color: 0xFF0000, type: 'spinning', spinSpeed: 0.11 },
                
                // Floating blocks that move up and down
                { pos: [15, 3, 16], size: [2, 2, 2], color: 0xFF9800, type: 'floating', floatRange: 3, floatSpeed: 0.03 },
                { pos: [-15, 3, 24], size: [2, 2, 2], color: 0xFF9800, type: 'floating', floatRange: 3, floatSpeed: 0.04 },
                { pos: [15, 3, 32], size: [2, 2, 2], color: 0xFF9800, type: 'floating', floatRange: 3, floatSpeed: 0.035 },
                { pos: [-15, 3, 40], size: [2, 2, 2], color: 0xFF9800, type: 'floating', floatRange: 3, floatSpeed: 0.045 },
                { pos: [15, 3, 48], size: [2, 2, 2], color: 0xFF9800, type: 'floating', floatRange: 3, floatSpeed: 0.038 },
                
                // Moving walls that slide back and forth
                { pos: [0, 2, 20], size: [20, 4, 1], color: 0x9E9E9E, type: 'moving', moveRange: 15, moveSpeed: 0.015 },
                { pos: [0, 2, 36], size: [20, 4, 1], color: 0x9E9E9E, type: 'moving', moveRange: 15, moveSpeed: 0.02 },
                { pos: [0, 2, 52], size: [20, 4, 1], color: 0x9E9E9E, type: 'moving', moveRange: 15, moveSpeed: 0.018 },
                
                // Speed boosters that launch you forward
                { pos: [0, 0.5, 14], size: [3, 0.5, 3], color: 0x00FF00, type: 'booster', boostPower: 0.8 },
                { pos: [0, 0.5, 30], size: [3, 0.5, 3], color: 0x00FF00, type: 'booster', boostPower: 0.8 },
                { pos: [0, 0.5, 46], size: [3, 0.5, 3], color: 0x00FF00, type: 'booster', boostPower: 0.8 },
                
                // Teleporters that move you to different locations
                { pos: [0, 0.5, 22], size: [2, 0.5, 2], color: 0x9C27B0, type: 'teleporter', target: [0, 2, 26] },
                { pos: [0, 0.5, 38], size: [2, 0.5, 2], color: 0x9C27B0, type: 'teleporter', target: [0, 2, 42] },
                { pos: [0, 0.5, 54], size: [2, 0.5, 2], color: 0x9C27B0, type: 'teleporter', target: [0, 2, 58] },
                
                // Bouncy platforms that make you jump higher
                { pos: [0, 0, 18], size: [4, 0.5, 4], color: 0xFFFF00, type: 'bouncy', bouncePower: 0.6 },
                { pos: [0, 0, 34], size: [4, 0.5, 4], color: 0xFFFF00, type: 'bouncy', bouncePower: 0.6 },
                { pos: [0, 0, 50], size: [4, 0.5, 4], color: 0xFFFF00, type: 'bouncy', bouncePower: 0.6 },
                
                // Ice platforms that make you slide
                { pos: [0, 0, 26], size: [4, 0.5, 4], color: 0x00FFFF, type: 'ice', slideFactor: 0.3 },
                { pos: [0, 0, 42], size: [4, 0.5, 4], color: 0x00FFFF, type: 'ice', slideFactor: 0.3 },
                { pos: [0, 0, 58], size: [4, 0.5, 4], color: 0x00FFFF, type: 'ice', slideFactor: 0.3 }
            ];
            
            // Create platform meshes
            const platformMeshes = [];
            platforms.forEach(platform => {
                const geometry = new THREE.BoxGeometry(platform.size[0], platform.size[1], platform.size[2]);
                const material = new THREE.MeshLambertMaterial({ color: platform.color });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(platform.pos[0], platform.pos[1], platform.pos[2]);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData = platform;
                scene.add(mesh);
                platformMeshes.push(mesh);
            });
            
            // Create obstacle meshes
            const obstacleMeshes = [];
            obstacles.forEach(obstacle => {
                const geometry = new THREE.BoxGeometry(obstacle.size[0], obstacle.size[1], obstacle.size[2]);
                const material = new THREE.MeshLambertMaterial({ color: obstacle.color });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(obstacle.pos[0], obstacle.pos[1], obstacle.pos[2]);
                mesh.castShadow = true;
                mesh.userData = obstacle;
                scene.add(mesh);
                obstacleMeshes.push(mesh);
            });
            
            // Create checkpoints - updated positions to match new platform layout
            const checkpoints = [
                [0, 2, 8],    // Checkpoint 1
                [0, 2, 24],   // Checkpoint 2
                [0, 2, 40],   // Checkpoint 3
                [0, 2, 56]    // Checkpoint 4
            ];
            
            const checkpointMeshes = [];
            checkpoints.forEach((cp, index) => {
                const geometry = new THREE.BoxGeometry(2, 2, 2);
                const material = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(cp[0], cp[1], cp[2]);
                scene.add(mesh);
                checkpointMeshes.push(mesh);
            });
            
            // Create player
            const playerGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const playerMaterial = new THREE.MeshLambertMaterial({ color: 0xFF0000 });
            const playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
            playerMesh.position.copy(playerPosition);
            playerMesh.castShadow = true;
            scene.add(playerMesh);
            
            // Create ground
            const groundGeometry = new THREE.PlaneGeometry(200, 200);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x8BC34A });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.5;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Input handling
            const keys = {};
            
            document.addEventListener('keydown', (e) => {
                keys[e.code] = true;
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });
            
            // Mouse movement
            let isPointerLocked = false;
            
            renderer.domElement.addEventListener('click', () => {
                renderer.domElement.requestPointerLock();
            });
            
            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === renderer.domElement;
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isPointerLocked) {
                    playerRotation.y -= e.movementX * mouseSensitivity;
                    playerRotation.x -= e.movementY * mouseSensitivity;
                    playerRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, playerRotation.x));
                }
            });
            
            // Update player
            function updatePlayer() {
                let moveX = 0, moveZ = 0;
                
                if (keys['KeyW']) {
                    moveZ -= Math.cos(playerRotation.y);
                    moveX -= Math.sin(playerRotation.y);
                }
                if (keys['KeyS']) {
                    moveZ += Math.cos(playerRotation.y);
                    moveX += Math.sin(playerRotation.y);
                }
                if (keys['KeyA']) {
                    moveX -= Math.cos(playerRotation.y);
                    moveZ += Math.sin(playerRotation.y);
                }
                if (keys['KeyD']) {
                    moveX += Math.cos(playerRotation.y);
                    moveZ -= Math.sin(playerRotation.y);
                }
                
                const length = Math.sqrt(moveX * moveX + moveZ * moveZ);
                if (length > 0) {
                    moveX /= length;
                    moveZ /= length;
                }
                
                playerPosition.x += moveX * moveSpeed;
                playerPosition.z += moveZ * moveSpeed;
                
                if (keys['Space'] && onGround) {
                    playerVelocity.y = jumpPower;
                    onGround = false;
                }
                
                playerVelocity.y += gravity;
                let newY = playerPosition.y + playerVelocity.y;
                
                // Collision detection
                onGround = false;
                for (let platform of platforms) {
                    const px = platform.pos[0];
                    const py = platform.pos[1];
                    const pz = platform.pos[2];
                    const sx = platform.size[0];
                    const sy = platform.size[1];
                    const sz = platform.size[2];
                    
                    if (playerPosition.x > px - sx/2 - 0.5 && playerPosition.x < px + sx/2 + 0.5 &&
                        playerPosition.z > pz - sz/2 - 0.5 && playerPosition.z < pz + sz/2 + 0.5) {
                        
                        if (playerVelocity.y <= 0 && newY <= py + sy + 0.5 && playerPosition.y >= py + sy) {
                            newY = py + sy + 0.5;
                            playerVelocity.y = 0;
                            onGround = true;
                        }
                    }
                }
                
                playerPosition.y = newY;
                
                // Check checkpoints
                for (let i = 0; i < checkpoints.length; i++) {
                    const cp = checkpoints[i];
                    const distance = Math.sqrt(
                        Math.pow(playerPosition.x - cp[0], 2) +
                        Math.pow(playerPosition.y - cp[1], 2) +
                        Math.pow(playerPosition.z - cp[2], 2)
                    );
                    
                    if (distance < 2 && i + 1 > checkpoint) {
                        checkpoint = i + 1;
                        document.getElementById('checkpoint').textContent = checkpoint;
                        checkpointMeshes[i].material.color.setHex(0x4CAF50);
                    }
                }
                
                if (playerPosition.y < -10) {
                    respawnPlayer();
                }
                
                if (playerPosition.z > 64) { // Updated final platform position
                    gameComplete();
                }
                
                playerMesh.position.copy(playerPosition);
            }
            
            function respawnPlayer() {
                deaths++;
                document.getElementById('deaths').textContent = deaths;
                
                if (checkpoint > 0) {
                    const cp = checkpoints[checkpoint - 1];
                    playerPosition.set(cp[0], cp[1] + 2, cp[2]);
                } else {
                    playerPosition.set(0, 2, 0);
                }
                
                playerVelocity.set(0, 0, 0);
            }
            
            function gameComplete() {
                gameRunning = false;
                const totalTime = Math.floor((Date.now() - startTime) / 1000);
                document.getElementById('finalCheckpoint').textContent = checkpoint;
                document.getElementById('finalDeaths').textContent = deaths;
                document.getElementById('finalTime').textContent = totalTime;
                document.getElementById('gameOver').style.display = 'block';
            }
            
            function restartGame() {
                checkpoint = 0;
                deaths = 0;
                startTime = Date.now();
                gameRunning = true;
                playerPosition.set(0, 2, 0);
                playerVelocity.set(0, 0, 0);
                playerRotation.set(0, 0, 0);
                onGround = false;
                
                checkpointMeshes.forEach(mesh => {
                    mesh.material.color.setHex(0xFFD700);
                });
                
                document.getElementById('checkpoint').textContent = checkpoint;
                document.getElementById('deaths').textContent = deaths;
                document.getElementById('gameOver').style.display = 'none';
            }
            
            // Update obstacles and activities
            let obstacleTime = 0;
            function updateObstacles() {
                obstacleTime += 0.016;
                
                // Update moving platforms
                platformMeshes.forEach((mesh, index) => {
                    const platform = platforms[index];
                    if (platform.type === 'moving') {
                        mesh.position.x = Math.sin(obstacleTime * 0.02) * 10;
                    }
                    if (platform.type === 'spinning') {
                        mesh.rotation.y = obstacleTime * 0.05;
                    }
                });
                
                // Update obstacles
                obstacleMeshes.forEach((mesh, index) => {
                    const obstacle = obstacles[index];
                    
                    if (obstacle.type === 'spinning') {
                        mesh.rotation.y = obstacleTime * obstacle.spinSpeed;
                    }
                    
                    if (obstacle.type === 'floating') {
                        mesh.position.y = obstacle.pos[1] + Math.sin(obstacleTime * obstacle.floatSpeed) * obstacle.floatRange;
                    }
                    
                    if (obstacle.type === 'moving') {
                        mesh.position.x = Math.sin(obstacleTime * obstacle.moveSpeed) * obstacle.moveRange;
                    }
                });
            }
            
            // Update camera
            function updateCamera() {
                const cameraOffset = new THREE.Vector3(0, 2, 5);
                cameraOffset.applyEuler(playerRotation);
                camera.position.copy(playerPosition).add(cameraOffset);
                camera.lookAt(playerPosition);
            }
            
            // Check special platform interactions
            function checkPlatformInteractions() {
                // Check speed boosters
                obstacles.forEach(obstacle => {
                    if (obstacle.type === 'booster') {
                        const distance = Math.sqrt(
                            Math.pow(playerPosition.x - obstacle.pos[0], 2) +
                            Math.pow(playerPosition.z - obstacle.pos[2], 2)
                        );
                        
                        if (distance < 2 && playerPosition.y < obstacle.pos[1] + 2) {
                            playerVelocity.z = -obstacle.boostPower;
                            console.log('Speed boost!');
                        }
                    }
                    
                    // Check teleporters
                    if (obstacle.type === 'teleporter') {
                        const distance = Math.sqrt(
                            Math.pow(playerPosition.x - obstacle.pos[0], 2) +
                            Math.pow(playerPosition.z - obstacle.pos[2], 2)
                        );
                        
                        if (distance < 1.5 && playerPosition.y < obstacle.pos[1] + 2) {
                            playerPosition.set(obstacle.target[0], obstacle.target[1], obstacle.target[2]);
                            console.log('Teleported!');
                        }
                    }
                    
                    // Check bouncy platforms
                    if (obstacle.type === 'bouncy') {
                        const distance = Math.sqrt(
                            Math.pow(playerPosition.x - obstacle.pos[0], 2) +
                            Math.pow(playerPosition.z - obstacle.pos[2], 2)
                        );
                        
                        if (distance < 2 && playerPosition.y < obstacle.pos[1] + 2) {
                            if (playerVelocity.y <= 0) {
                                playerVelocity.y = obstacle.bouncePower;
                                console.log('Bounce!');
                            }
                        }
                    }
                    
                    // Check ice platforms
                    if (obstacle.type === 'ice') {
                        const distance = Math.sqrt(
                            Math.pow(playerPosition.x - obstacle.pos[0], 2) +
                            Math.pow(playerPosition.z - obstacle.pos[2], 2)
                        );
                        
                        if (distance < 2 && playerPosition.y < obstacle.pos[1] + 2) {
                            // Apply ice sliding effect
                            if (keys['KeyW'] || keys['KeyS'] || keys['KeyA'] || keys['KeyD']) {
                                playerVelocity.x *= (1 + obstacle.slideFactor);
                                playerVelocity.z *= (1 + obstacle.slideFactor);
                            }
                        }
                    }
                });
            }
            
            // Game loop
            function gameLoop() {
                if (gameRunning) {
                    updatePlayer();
                    updateObstacles(); // Call updateObstacles here
                    updateCamera();
                    checkPlatformInteractions(); // Call checkPlatformInteractions here
                    
                    const currentTime = Math.floor((Date.now() - startTime) / 1000);
                    document.getElementById('time').textContent = currentTime;
                }
                
                renderer.render(scene, camera);
                requestAnimationFrame(gameLoop);
            }
            
            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            console.log('Starting game loop...');
            gameLoop();
        });
    </script>
</body>
</html>
